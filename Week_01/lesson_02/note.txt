时间复杂度：
常见 × 7 
	常数时间复杂度
	对数时间复杂度
	...

特征：不考虑系数；
原则：代码根据N的不同会运行多少次；
计算手段：操作本身的时间成本 * 操作执行的次数；

如果循环是并列的，那么时间复杂度就只是叠加，而不是相乘；

分析代码的时间复杂度 & 空间复杂度；

------
1+2+...+N;
算法1：暴力求解；
时间复杂度：O(n)

算法2：计算公式；
时间复杂度：O(1)

递归的时间复杂度：
手段：把递归过程的状态树画出来；
递归树有N层，时间复杂度就为O(2^N)；

递归的过程往往会有重复计算，这导致了夸张的时间复杂度；
手段：添加一个缓存/备忘录；

------
主定理：
任何一个分支/递归的函数，都可以求出其时间复杂度；

二分查找：O(logN)；
二叉树遍历：O(N)； 每个节点都只会被访问一次
有序二维矩阵中的查找：O(N);
归并排序：O(NlogN)；

------
二叉树的各种遍历方式：时间复杂度都是O(N)；
图的遍历也是一个道理；
DFS/BFS：搜索空间中的节点总数；


空间复杂度：
1 数组的长度就是空间复杂度；
2 如果使用了递归的话，递归的深度就是空间复杂度；

------
应用：爬楼梯算法的时间复杂度 & 空间复杂度的分析；











